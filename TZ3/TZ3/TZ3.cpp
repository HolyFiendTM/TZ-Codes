#include <iostream> //подключаем библиотеку для ввода-вывода
#include <fstream> //подключаем библиотеку для работы с файлами
#include <string> //подключаем библиотеку для работы со строками (в данном случае для работы getline())
using namespace std;
int main()
{
    ifstream f; //создаём объект f для чтения файла
    f.open("CreativeTask3.txt"); //открываем файл и связываем его с объектом f
    int count = 1; //число, которое нужно будет найти в строке (увеличивается на 1 после нахождения)
    string s; //создаём строку s
    getline(f, s); //копируем данные объекта f в строку s
    f.close(); //закрываем файл
    string res = ""; //итоговое предложение
    while (s.size() > 0) { //будет выполняться, пока в строке находится хотя бы 1 символ
        int flag = 0; //индикатор, показывающий, нашли ли мы необходимое число (рассматриваемое на данной итерации цикла); 1 - да, 0 - нет
        if (count < 10) { //развилка: между однозначным и двузначным необходимым числом есть разница в работе кода (сейчас рассматриваются только однозначные числа)
            for (int i = 0; i < s.size() - 1; i++) { //проходимся по строке ("идём" до предпоследнего элемента, так как последний элемент - буква (у нас конструкция "однозначное число + буква (набор букв))", а мы ищем число)
                if (i == 0) { //если рассматриваем первый элемент, то (условие, чтобы не возникало проблем с проверкой предыдущего элемента)
                    if ((s[i] - '0') == count && s[i + 1] >= 'A' && s[i + 1] <= 'Z') { //проверяем, чтобы число было однозначным (спереди была буква (только спереди, потому что первый элемент)) и было необходимым
                        int j = i; //переменная j, равная i (потом будем использовать в другом цикле, чтобы работать с набором букв)
                        int k = 1; //переменная, показывающая количество количество символов конструкции "число + буква (буквы)" (по умолчанию 1, потому что число однозначное)
                        while (s[j + 1] >= 'A' && s[j + 1] <= 'Z') { //цикл, выполняющийся до тех пор, пока следующий элемент - буква
                            res += s[j + 1]; //добавляем букву в итоговое предложение
                            k++; //увеличиваем k на 1 (на один символ стало больше)
                            j++; //увеличиваем j на 1 (чтобы "идти" дальше по набору букв)
                        }
                        s.erase(i, k); //удаляем из строки k элементов, начиная с i-го элемента (удаляем использованную конструкцию "число + буква (набор букв)", чтобы в конечном итоге в строке ничего не осталось и внешний цикл завершился)
                        flag = 1; //мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                    }
                    if (flag == 1) { //если мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                        count++; //увеличиваем необходимое для поиска число на 1
                        break; //выходим из цикла
                    }
                }
                else { //если элемент не первый
                    if ((s[i] - '0') == count && s[i + 1] >= 'A' && s[i + 1] <= 'Z' && s[i - 1] >= 'A' && s[i - 1] <= 'Z') { //проверяем, чтобы число было однозначным (окружено буквами) и было необходимым
                        int j = i; //переменная j, равная i (потом будем использовать в другом цикле, чтобы работать с набором букв)
                        int k = 1; //переменная, показывающая количество количество символов конструкции "число + буква (буквы)" (по умолчанию 1, потому что число однозначное)
                        while (s[j + 1] >= 'A' && s[j + 1] <= 'Z') { //цикл, выполняющийся до тех пор, пока следующий элемент - буква
                            res += s[j + 1]; //добавляем букву в итоговое предложение
                            k++; //увеличиваем k на 1 (на один символ стало больше)
                            j++; //увеличиваем j на 1 (чтобы "идти" дальше по набору букв)
                        }
                        s.erase(i, k); //удаляем из строки k элементов, начиная с i-го элемента (удаляем использованную конструкцию "число + буква (набор букв)", чтобы в конечном итоге в строке ничего не осталось и внешний цикл завершился)
                        flag = 1; //мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                    }
                    if (flag == 1) { //если мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                        count++; //увеличиваем необходимое для поиска число на 1
                        break; //выходим из цикла
                    }
                }
            }
        }
        else { //иначе (если необходимое число двузначное)
            for (int i = 0; i < s.size() - 2; i++) { //проходимся по строке ("идём" до 3 элемента с конца, потому что 2 элемент с конца - цифра числа (разряд единиц), а последний элемент - буква, а ищем мы цифру именно РАЗРЯДА ДЕСЯТКОВ числа)
                string countstr = to_string(s[i] - '0') + to_string(s[i + 1] - '0'); //создаём строку countstr, в которую заносим сначала десятичное значение по ASCII таблице элемента s[i], а потом элемента s[i+1] (просто чтобы было удобнее сравнивать с необходимым числом)
                if (countstr == to_string(count) && s[i] >= 48 && s[i] <= 57 && s[i + 1] >= 48 && s[i + 1] <= 57) { //если необходимое число совпадает с рассматриваемым, причём первый и второй символы рассматриваемого числа являются цифрами, то
                    int j = i; //переменная j, равная i (потом будем использовать в другом цикле, чтобы работать с набором букв)
                    int k = 2; //переменная, показывающая количество количество символов конструкции "число + буква (буквы)" (по умолчанию 2, потому что число двузначное)
                    while (s[j + 2] >= 'A' && s[j + 2] <= 'Z') { //цикл, выполняющийся до тех пор, пока следующий элемент - буква
                        res += s[j + 2]; //добавляем букву в итоговое предложение
                        k++; //увеличиваем k на 1 (на один символ стало больше)
                        j++; //увеличиваем j на 1 (чтобы "идти" дальше по набору букв)
                    }
                    s.erase(i, k); //удаляем из строки k элементов, начиная с i-го элемента (удаляем использованную конструкцию "число + буква (набор букв)", чтобы в конечном итоге в строке ничего не осталось и внешний цикл завершился)
                    flag = 1; //мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                }
                if (flag == 1) { //если мы нашли необходимое число и записали в предложение прикреплённые к нему буквы (букву)
                    count++; //увеличиваем необходимое для поиска число на 1
                    break; //выходим из цикла
                }
            }
        }
    }
    cout << res; //выводим итоговое предложение
    //пиздец я тут надушнил в объяснении
    //единственное, что нужно добавить, '0' в ASCII таблице имеет эквивалент в виде десятичного числа 48, поэтому, когда я пишу s[i]-'0', я подразумеваю вычитание 48 из числового эквивалента символа s[i] в ASCII таблице. То есть, если s[i] - это '7', чей код ASCII равен 55, то 55-48=7, это считается строкой, поэтому её можно спокойно сравнивать с другими строками... Крч, удобно
    //общую идею писать не буду, иначе скорую придётся вызывать
}